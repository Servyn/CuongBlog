<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Function trong Javascript - CuongBlog</title><meta name="description" content="Function(Hàm) là gì? Function (hàm, chức năng), gọi chung là subprogram (chương trình con) có thể được gọi ở bên ngoài hoặc bên trong chính nó. Nó bao&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://servyn.github.io/CuongBlog/blog/function-trong-javascript/"><link rel="alternate" type="application/atom+xml" href="https://servyn.github.io/CuongBlog/feed.xml"><link rel="alternate" type="application/json" href="https://servyn.github.io/CuongBlog/feed.json"><meta property="og:title" content="Function trong Javascript"><meta property="og:site_name" content="CuongBlog"><meta property="og:description" content="Function(Hàm) là gì? Function (hàm, chức năng), gọi chung là subprogram (chương trình con) có thể được gọi ở bên ngoài hoặc bên trong chính nó. Nó bao&hellip;"><meta property="og:url" content="https://servyn.github.io/CuongBlog/blog/function-trong-javascript/"><meta property="og:type" content="article"><link rel="preload" href="https://servyn.github.io/CuongBlog/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="https://servyn.github.io/CuongBlog/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono-italic.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://servyn.github.io/CuongBlog/assets/css/style.css?v=2e8e4a056cb849f85447fcd1306475ca"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://servyn.github.io/CuongBlog/blog/function-trong-javascript/"},"headline":"Function trong Javascript","datePublished":"2024-12-11T05:28+07:00","dateModified":"2024-12-31T05:30+07:00","description":"Function(Hàm) là gì? Function (hàm, chức năng), gọi chung là subprogram (chương trình con) có thể được gọi ở bên ngoài hoặc bên trong chính nó. Nó bao&hellip;","author":{"@type":"Person","name":"Cuong","url":"https://servyn.github.io/CuongBlog/authors/cuong/"},"publisher":{"@type":"Organization","name":"Cuong"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><div class="container container--center"><header class="header"><div class="header__logo"><a class="logo" href="https://servyn.github.io/CuongBlog/">CuongBlog</a></div><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://servyn.github.io/CuongBlog/" target="_self">Home</a></li><li><a href="https://servyn.github.io/CuongBlog/portfolio/" target="_self">Portfolio</a></li><li><a href="https://servyn.github.io/CuongBlog/blog/" title="Danh sách" target="_self">Blog</a></li><li><a href="https://servyn.github.io/CuongBlog/contact/" target="_self">Contact</a></li></ul></nav></header><main class="content"><article class="post"><header><h1 class="post__title">Function trong Javascript</h1><div class="post__meta"><time datetime="2024-12-11T05:28" class="post__date">December 11, 2024 </time><span class="post__author"><a href="https://servyn.github.io/CuongBlog/authors/cuong/" class="feed__author">Cuong</a></span></div><div class="post__tags"><a href="https://servyn.github.io/CuongBlog/tags/tu-hoc-javascript/" class="invert">Tự học Javascript</a></div></header><div class="post__entry"><h3><strong>Function(Hàm) là gì?</strong></h3><p><strong>Function</strong> (hàm, chức năng), gọi chung là <strong>subprogram (chương trình con) </strong>có thể được gọi ở bên ngoài hoặc bên trong chính nó.</p><p>Nó bao gồm tập hợp các câu lệnh gọi là <strong>function</strong> <strong>body. </strong>Các giá trị có thể truyền đến một hàm, và một hàm có thể trả về giá trị. </p><p>Bây giờ, với các ứng dụng hiện đại, các function có thể là một chương trình hoàn chỉnh, chứ không phải là khái niệm tổng quát như ''subprogram" nữa. Có sự khác nhau giữa function và procedure (thủ tục) rằng sự lý tưởng của function nên trả về một giá trị còn procedure thì không ( bây giờ điều này có thể thay đổi theo ngôn ngữ lập trình).</p><h3>1. Khai báo hàm</h3><p>Để khai báo hàm, chúng ta dùng từ khóa <code>function,</code> theo sau nó là:</p><ul><li>Tên hàm</li><li>Danh sách các tham số truyền vào hàm, được đặt trong ngoặc đơn và cách nhau bởi dấu phẩy.</li><li>Các câu lệnh của JavaScript để tạo ra một hàm, được đặt trong ngoặc nhọn <code>{...}</code>.</li></ul><p>Ví dụ, để định nghĩa một hàm in ra chữ "Hello World" ở console:</p><pre class="language-javascript" tabindex="0"><code>function sayHello () {
  console.log("Hello World");
}</code></pre><h3>2. Biểu thức hàm (Hàm trong biến)</h3><p>Trong khi việc khai báo hàm ở trên là một câu lệnh về mặt cú pháp, các hàm cũng có thể tạo ra bằng một biểu thức hàm (<strong>function expression</strong>). Một hàm như vậy có thể <strong>nặc danh</strong>; nó không cần phải có tên. Ví dụ, hàm sayHello ở trên có thể được khai báo như sau:</p><pre class="language-javascript" tabindex="0"><code>const sayHello = function() {
     console.log("Hello World");
}</code></pre><p>Tuy nhiên, một cái tên <em>có thể</em> được cung cấp trong một biểu thức hàm. Việc cung cấp tên cho phép hàm có thể chạy chính nó, hoặc có thể sử dụng hệ thống debug để nhận dạng hàm trong stack traces.</p><pre class="language-javascript" tabindex="0"><code>const hello = function sayHello() {
     console.log("Hello World");
}</code></pre><h3>3. Các ràng buộc về tên hàm</h3><p>Javascript cũng giống như các ngôn ngữ khác nó cũng có các ràng buộc về tên hàm sau đây:</p><ul><li>Tên hàm phải được bắt đầu bằng chữ cái (a-z,A-Z) hoặc ký tự <code>_</code>.</li><li>Tên hàm không được bắt đầu bằng số, các ký tự khác ký tự <code>_</code>.</li></ul><h3>Các loại hàm</h3><h3>1. Hàm cơ bản</h3><p>Đây là dạng hàm cơ bản nhất trong Javascript, cú pháp có dạng như sau:</p><pre class="language-javascript" tabindex="0"><code>function doSomeThing() {
     // Do Something
}</code></pre><p>Trong đó: doSomeThing là tên của hàm bạn muốn đặt và <code>function</code> là từ khóa bắt buộc.</p><p>Ví dụ: Tạo hàm in ra tên website codelearn ở console</p><pre class="language-javascript" tabindex="0"><code>function getWebsite() {
     console.log("https://codelearn.io/");
}</code></pre><h3>2. Hàm có tham số truyền vào</h3><p>Đây là một dạng hàm rất hay được sử dụng, cú pháp có dạng như sau:</p><pre class="language-javascript" tabindex="0"><code>function funName(param_1, ..., pram_n) {
	//code
}</code></pre><p><strong>Trong đó:</strong></p><ul><li><strong>funName </strong>là tên của hàm các bạn muốn đặt.</li><li><strong>param_1,...,pram_n</strong> là các tham số mà các bạn muốn truyền vào hàm(không giới hạn số lượng).</li></ul><p><strong>VD:</strong> Tạo hàm tính tổng 2 số</p><pre class="language-javascript" tabindex="0"><code>function getSum(a, b) {
	console.log("Tổng: " + (a + b));
}</code></pre><h3>3. Hàm có tham số mặc định</h3><p>Đây thực ra là dạng hàm có truyền tham số và đồng thời xét luôn giá trị mặc định cho các tham số đó. Cú pháp:</p><pre class="language-javascript" tabindex="0"><code>function funName(param_1 = value_1, ..., pram_n = value_2) {
	//code
}</code></pre><p><strong>Trong đó</strong>:</p><ul><li><strong>funName </strong>là tên của hàm các bạn muốn đặt.</li><li><strong>param_1,...,pram_n</strong> là các tham số mà các bạn muốn truyền vào hàm(không giới hạn số lượng).</li><li><strong>value_1,...,value_n</strong> là các giá trị tương ứng với các pram.</li></ul><p><strong>VD</strong>: với hàm <strong>getSum</strong> ở trên mình sẽ xét tham số mặc định cho nó.</p><pre class="language-javascript" tabindex="0"><code>function getSum(a = 5, b = 10) {
	console.log("Tổng: " + (a + b));
}</code></pre><h3>4. Hàm có và không trả về giá trị</h3><p>Trong javascript có hai loại hàm,đó là hàm có giá trị trả về và hàm không có giá trị trả về.</p><ul><li>Đối với hàm có giá trị trả về thì phải sử dụng từ khóa <code>return</code></li><li>Và ngược lại đối với hàm không có giá trị trả về thì không có từ khóa <code>return</code></li></ul><p><strong>VD</strong>: khai báo hàm getSum ở trên là hàm có giá trị trả về.</p><pre class="language-javascript" tabindex="0"><code>function getSum(a, b) {
	return a + b;
}</code></pre><h3>Gọi hàm</h3><p><em>Việc định nghĩa</em> một hàm sẽ không <em>thực thi</em> nó. Định nghĩa một hàm đơn giản chỉ là đặt tên cho hàm và chỉ định những việc cụ thể sẽ làm khi hàm đó được gọi.</p><p>Ví dụ, nếu bạn định nghĩa hàm sayHello, bạn có thể gọi nó như sau:</p><pre class="language-javascript" tabindex="0"><code>function sayHello () {
  console.log("Hello World");
}

sayHello(); // Gọi hàm</code></pre><p>Câu lệnh trên gọi hàm sayHello, kết quả trả về chữ "Hello World" tại console.</p><p>Các hàm phải đặt <em>trong phạm vi (</em><em>in scope)</em> khi nó được gọi, nhưng việc khai báo hàm có thể được hoisted (câu lệnh khai báo hàm xuất hiện bên dưới dòng gọi hàm trong đoạn code), như ví dụ này:</p><pre class="language-javascript" tabindex="0"><code>console.log(getAreaOfSquare(5));

/* ... */

function getAreaOfSquare(n) { 
    return n*n;
} </code></pre><p>Phạm vi (scope) của một hàm là khoảng không gian bên trong hàm mà nó được khai báo (hoặc là cả chương trình, nếu nó được khai bảo ở top level, tức là nó không nằm trong hàm nào khác).</p><p><strong>Lưu ý: </strong>Điều này chỉ đúng khi định nghĩa một hàm bằng cách sử dụng các cú pháp ở trên (ví dụ <code>function funcName(){}</code>). Điều này có nghĩa rằng function hoisting chỉ hoạt động với cách khai báo hàm thông thường (function declarations) - function hoisting không hoạt động đối với hàm được khai báo bằng biểu thức hàm (function expression). Ví dụ, đoạn code dưới đây sẽ không hoạt động:</p><pre class="language-javascript" tabindex="0"><code>console.log(getAreaOfSquare); // ReferenceError: getAreaOfSquare is not defined
console.log(getAreaOfSquare(5)); // ReferenceError: getAreaOfSquare is not defined
getAreaOfSquare = function (n) {
  return n * n;
}</code></pre><h3>Một hàm có thể gọi chính nó</h3><p>Ví dụ, đây là một hàm tính giai thừa đệ quy:</p><pre class="language-javascript" tabindex="0"><code>function factorial(n){
  if ((n == 0) || (n == 1))
    return 1;
  else
    return (n * factorial(n - 1));
}</code></pre><p>Bạn có thể tính giai thừa của <code>1</code> tới <code>3</code> như sau:</p><pre class="language-javascript" tabindex="0"><code>var a, b, c;
a = factorial(1); // a gets the value 1
b = factorial(2); // b gets the value 2
c = factorial(3); // c gets the value 6</code></pre><p>Có những cách khác để gọi hàm. Có nhiều trường hợp mà tại đó một hàm cần phải được gọi một cách tự động, hoặc làm thay đổi số lượng đối số truyền vào một hàm, hoặc trong trường hợp mà việc gọi hàm cần được gắn với một object nhất định được quyết định tại thời điểm runtime.</p><p>Điều đó lại hóa ra là <em>các hàm tự bản thân chúng là các object</em>, và kết quả là, những object này có các phương thức. Một trong số chúng, phương thức <code>apply()</code>, có thể được dùng để đạt được mục tiêu này.</p><h3>Phạm vi của hàm (Function Scope)</h3><p>Các biến được định nghĩa bên trong một hàm không thể được truy cập từ nơi nào khác bên ngoài hàm, bởi vì biến đó được định nghĩa chỉ trong phạm vi của hàm. Tuy nhiên, một hàm có thể truy cập đến mọi biến và mọi hàm khác trong cùng phạm vi mà nó được định nghĩa.</p><p>Nói cách khác, một hàm được định nghĩa trong phạm vi global có thể truy cập tới tất cả các biến đã được định nghĩa trong phạm vi global. Một hàm được định nghĩa bên trong một hàm khác có thể truy cập đến tất cả biến được định nghĩa bên trong hàm cha của nó, và bất cứ biến nào khác mà hàm cha của nó có quyền truy cập đến. Các bạn có thể tham khảo ví dụ dưới đây:</p><pre class="language-javascript" tabindex="0"><code>// Các biến sau được định nghĩa trong phạm vi global scope
var num1 = 20,
    num2 = 3,
    name = "Khoa";

// Hàm này được định nghĩa trong phạm vi global scope
function multiply() {
  return num1 * num2;
}

multiply(); // Returns 60

// Một ví dụ hàm lồng nhau
function getScore () {
  var num1 = 50,
      num2 = 50;
  
  function add() {
    return name + " scored " + (num1 + num2);
  }
  
  return add();
}

getScore(); // Returns "Khoa scored 100"</code></pre><h3>Các tham số của Function</h3><p>Kể từ ES6, xuất hiện 2 dạng tham số mới: <strong><em>default parameters</em></strong> và <strong><em>rest parameters</em></strong></p><h3><strong><em>1. Default parameters</em></strong></h3><p><em>Trong JavaScript, các tham số của function được mặc định là <code>undefined</code>. Tuy nhiên, trong một số trường hợp nó có thể hữu ích để thiết lập một giá trị mặc định khác. Đây chính xác là điều mà default parameters sẽ làm.</em></p><h4 id="Khi_không_có_default_parameters_trước_ES6">Khi không có default parameters (trước ES6)</h4><p>Trong quá khứ, cách thông thường để thiết lập các giá trị mặc định là kiểm định giá trị của các tham số bên trong body của function và gán giá trị cho nó nếu nó là <code>undefined</code>.</p><p>Trong ví dụ sau, nếu không có giá trị nào được truyền cho <code>b</code>, giá trị của nó sẽ là <code>undefined</code> khi thực hiện tính toán <code>a*b</code>, và việc gọi hàm <code>multiply</code> sẽ trả về <code>NaN</code>. Tuy nhiên, điều này bị ngăn chặn bởi dòng thứ 2 trong ví dụ này:</p><pre class="language-javascript" tabindex="0"><code>function multiply(a, b) {
  b = typeof b !== 'undefined' ?  b : 1;

  return a*b;
}

multiply(5); // 5</code></pre><h4 id="Khi_có_default_parameters_sau_ES6">Khi có default parameters (sau ES6)</h4><p>Với <em>default parameters</em>, việc kiểm tra thủ công bên trong body của function không còn cần thiết. Bạn có thể đơn giản chỉ là đặt <code>1</code> vào làm giá trị mặc định cho <code>b</code> ngay tại head của function:</p><pre class="language-javascript" tabindex="0"><code>function multiply(a, b = 1) {
  return a*b;
}

multiply(5); // 5</code></pre><h3><strong><em>2. Rest parameters</em></strong></h3><p>Cú pháp <strong>rest parameter</strong> cho phép chúng ta dùng 1 mảng để đại diện cho số lượng vô hạn các đối số.</p><p>Trong ví dụ sau, hàm <code>multiply</code> sử dụng <em>rest parameters</em> để thu thập các đối số kể từ đối số hứ hai trở về đến hết. Hàm này sau đó sẽ nhân những đối số này với đối số đầu tiên.</p><pre class="language-javascript" tabindex="0"><code>function multiply(multiplier, ...theArgs) {
  return theArgs.map(x =&gt; multiplier * x);
}

var arr = multiply(2, 1, 2, 3);
console.log(arr); // [2, 4, 6]</code></pre><h3>Arrow Function</h3><p>Trong ES6, <strong>arrow function</strong> là một cú pháp mới dùng để viết các hàm trong <strong>JavaScript</strong>. Nó giúp tiết kiệm thời gian phát triển và đơn giản hóa phạm vi function (<strong>function scope</strong>).</p><p><strong>Arrow function</strong> - còn được gọi là <strong>"fat arrow"</strong>, là cú pháp được mượn từ <strong>CoffeeScript</strong> (một ngôn ngữ chuyển tiếp), cú pháp này là cách ngắn gọn hơn dùng để viết function. Ở đây sử dụng kí tự <code>=&gt;</code>, trông giống như một mũi tên "béo". <strong>Arrow function</strong> là một hàm vô danh và nó thay đổi cách <code>this</code> bind đến function. <strong>Arrow function</strong> làm code của ta trông ngắn gọn hơn, giúp đơn giản hóa function scoping cũng như từ khóa <code>this</code>.</p><p>Dưới đây là 1 vài ví dụ về việc sử dụng <strong>Arrow fucntion</strong> trong <strong>Javascript</strong></p><h4><strong>1. Trường hợp có nhiều tham số</strong></h4><pre class="language-javascript" tabindex="0"><code>// (param1, param2, paramN) =&gt; expression 
 
// ES5 
var multiply = function(x, y) {
    return x * y;
}; 
 
// ES6 
var multiply = (x, y) =&gt; { return x * y };</code></pre><p>Ví dụ trên cho cùng một kết quả, tuy nhiên cú pháp với arrow function tốn ít dòng mã hơn. Trong trường hợp chỉ có một biểu thức thì không cần tới dấu ngoặc nhọn: Ví dụ trên có thể viết lại như sau:</p><pre class="language-javascript" tabindex="0"><code>var multiply = (x, y) =&gt; x * y ;</code></pre><h4>2. Trường hợp có 1 tham số</h4><p>Dấu ngoặc đơn là không bắt buộc khi chỉ có 1 tham số.</p><pre class="language-javascript" tabindex="0"><code>//ES5 
var phraseSplitterEs5 = function phraseSplitter(phrase) { 
    return phrase.split(' '); 
}; 
 
//ES6 
var phraseSplitterEs6 = phrase =&gt; phrase.split(" "); 
 
console.log(phraseSplitterEs6("Love Codelearn"));  // ["Love", "Codelearn"]</code></pre><h4>3. Trường hợp không có tham số</h4><p>Dấu ngoặc đơn là bắt buộc khi không có tham số.</p><pre class="language-javascript" tabindex="0"><code>// ES5
var hello = function sayHello() {
     console.log("Hello World");
}

// ES6
var hello = () =&gt; { console.log("Hello World"); }

hello(); // Hello World</code></pre><h3>Closures</h3><p><strong>Closures</strong> là một trong những chức năng quyền lực nhất của JavaScript. JavaScript cho phép lồng các function vào nhau, và cấp quyền cho function con, để function con có toàn quyền truy cập vào tất cả các biến và function được định nghĩa bên trong function cha (và tất cả biến và function mà function cha được cấp quyền truy cập đến).</p><p>Tuy nhiên, function cha không có quyền truy cập đến các biến và function được định nghĩa bên trong function con. Điều này tạo nên một dạng bảo mật khép kín cho các biến của function con.</p><p>Bên cạnh đó, vì function con có quyền truy cập đến scope của function cha, các biến và function được định nghĩa bên trong function cha sẽ vẫn tồn tại dù việc thực thi function cha đã kết thúc, nếu function con xoay sở để tồn tại lâu hơn thời gian sống của function cha. Một closure được tạo ra khi một function con bằng cách nào đó trở nên khả dụng với bất kỳ scope nào bên ngoài function cha.</p><p>Hãy xem các ví dụ sau đây để hiểu hơn về <strong>Closures</strong></p><p><strong>VD1:</strong></p><pre class="language-javascript" tabindex="0"><code>function numberGenerator() {
  // Local “free” variable that ends up within the closure
  var num = 1;
  function checkNumber() {
    console.log(num);
  }
  num++;

  return checkNumber;
}

var number = numberGenerator();
number(); // 2</code></pre><p>Trong ví dụ trên, hàm <code>numberGenerator()</code> tạo ra một biến local <code>num</code> và <code>checkNumber()</code> (một hàm in ra num trong console). Hàm <code>checkNumber()</code> không có bất kỳ biến local nào trong nó. Tuy nhiên, nó có quyền truy cập vào các biến bên ngoài function, bởi vì <code>numberGenerator()</code> là một closure. Do đó, nó có thể sử dụng biến <code>num</code> được khai báo trong <code>numberGenerator()</code> để log <code>num</code> trong console sau khi <code>numberGenerator()</code> được trả lại.</p><p><strong>VD2:</strong></p><pre class="language-javascript" tabindex="0"><code>function sayHello() {
  var say = function() { console.log(hello); }
  // Local variable that ends up within the closure
  var hello = 'Hello, world!';

  return say;
}
var sayHelloClosure = sayHello();
sayHelloClosure(); // ‘Hello, world!’</code></pre><p>Chú ý, biến <code>hello</code> được khai báo sau anonymous function nhưng vẫn có thể truy cập biến <code>hello</code>. Điều này là do biến <code>hello</code> đã được khai báo trong function <em>scope</em> tại thời điểm được tạo ra, làm cho nó có sẵn khi anonymous function được thực thi.</p><h3>Callback Function</h3><p><strong>Callback function</strong> có thể được hiểu nôm na như sau: callback tức là ta truyền một đoạn code <strong>(Hàm A)</strong> này vào một đoạn code khác <strong>(Hàm B)</strong>. Tới một thời điểm nào đó, Hàm A sẽ được hàm B gọi lại (<strong>callback</strong>)<strong>. Javascript</strong> là một ngôn ngữ <strong>lập trình hướng sự kiện</strong> và <strong>bất đồng bộ</strong> nên <strong>callback function</strong> đóng vai trò rất quan trọng, bạn sẽ truyền một <strong>callback function</strong> vào các sự kiện và xử lý bất đồng bộ đó..</p><h3>Tạm kết</h3><p>Như vậy trong bài viết này, chúng ta đã cùng nhau tìm hiểu những vấn đề cơ bản về Function trong Javascript.</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on December 31, 2024</p><div class="post__share"></div></footer><nav class="pagination"><div class="pagination__title"><span>Read other posts</span></div><div class="pagination__buttons"><a href="https://servyn.github.io/CuongBlog/blog/postlisting/" class="btn previous" rel="prev" aria-label="[MISSING TRANSLATION]:  Các framework cho Javascript "><span class="btn__icon">←</span> <span class="btn__text">Các framework cho Javascript</span> </a><a href="https://servyn.github.io/CuongBlog/blog/vong-lap-trong-javascript/" class="btn next" rel="next" aria-label="[MISSING TRANSLATION]:  Vòng lặp trong Javascript "><span class="btn__text">Vòng lặp trong Javascript</span> <span class="btn__icon">→</span></a></div></nav></article></main><footer class="footer"><div class="footer__inner"><div class="footer__copyright"><footer><audio id="background-music" autoplay="autoplay" loop="loop" controls="controls"><source src="https://servyn.github.io/CuongBlog/media/files/Homemusic.mp3" type="audio/mpeg">Your browser does not support the audio element.</audio><script>const audio = document.getElementById('background-music');

    // Lấy vị trí phát hiện tại từ Local Storage (nếu có)
    const savedTime = localStorage.getItem('audioCurrentTime');
    const isPaused = localStorage.getItem('audioPaused') === 'true';

    // Nếu có thời gian đã lưu, thiết lập lại vị trí phát nhạc
    if (savedTime) {
        audio.currentTime = savedTime;
    }

    // Kiểm tra trạng thái âm thanh
    if (isPaused) {
        audio.pause(); // Nếu pause, nhạc dừng lại
    } else {
        audio.play(); // Nếu chưa pause, nhạc tiếp tục phát
    }

    // Lưu trạng thái play/pause vào Local Storage khi nhạc bắt đầu phát
    audio.addEventListener('play', () => {
        localStorage.setItem('audioPaused', 'false');
    });

    // Lưu trạng thái pause vào Local Storage khi nhạc dừng
    audio.addEventListener('pause', () => {
        localStorage.setItem('audioPaused', 'true');
    });

    // Lưu vị trí phát hiện tại vào Local Storage trước khi người dùng rời trang
    window.addEventListener('beforeunload', () => {
        localStorage.setItem('audioCurrentTime', audio.currentTime);
    });</script><div class="footer-content"><br><img src="https://servyn.github.io/CuongBlog/media/files/Logo.png" alt="Logo" width="136" height="136"><p>© 2024 by CAO MANH CUONG</p></div></footer></div></div></footer></div><script defer="defer" src="https://servyn.github.io/CuongBlog/assets/js/scripts.min.js?v=c2232aa7558e9517946129d2a1b8c770"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>